## C++类的理解
### 基础

+ 一个类包含另一个类就具有了这个类的功能。  
+ 一个类包含一个抽象类，则拥有了抽象类的潜在功能。  
+ 一个类的方法的参数可以是一个类，返回值可以是一个类。  
+ 一个类的函数可以返回类的成员变量的地址。  
+ 一个类中public中typedef后的定义可以通过类名直接调用。  

### 静态成员函数和变量

+ 类中的public静态成员函数可以通过类名直接调用。  
+ 类中的静态成员函数中不隐含this指针。  
+ 类中的静态成员函数不能访问类中的普通成员函数和变量，可以访问静态成员函数和变量，也可以访问构造函数。  
+ 类中的静态成员变量，必须要在类外再声明(分配空间)。  
+ 类中的public静态成员变量可以通过类名直接调用。  

### 类的继承和虚函数

+ 虚函数机制，64位操作系统，抽象类实例化对象中前8个字节存储的是一个指针，指向的是一个函数指针数组。
+ 一个类继承父类，则拥有了所继承类的public和protected中的所有。  
+ 初始化一个抽象类实例时，会根据初始化对象的实际地址去访问虚函数。  
+ 一个类中的非纯虚函数必须要实现，一个类的纯虚函数不实现。  
+ 一个类继承的父类有虚函数和纯虚函数，如果要实例化这个类，则必须实现这个类继承的父类的所有纯虚函数方法。  
+ 一个类b继承的父类c有虚函数和纯虚函数，如果不需要实例化类b，则类b无需实现其父类c的所有纯虚函数方法，如果此时又有一个类a继承于类b，且需要实例化类a，则必须在类a中实现类c中的所有纯虚函数方法。  
+ 一个类a继承于类b，类b继承于类c，类c中含有虚函数和纯虚函数，如果类b实现了类c中所有的纯虚函数方法，则类a中无需实现类c中的纯虚函数方法，即可实例化。  
+ 综上，含有纯虚函数的类，必须要有子类(可以是子类的子类)实现其纯虚函数，如果不实现纯虚函数且不实例化子类，编译可以通过，实例化子类则编译报错。  
+ 若将子类对象的地址赋值给父类指针，则父类指针不能访问子类对象独有的函数。  
+ 若将父类对象的地址赋值给子类指针，调用虚函数时，则子类指针会访问父类的虚函数；调用成员函数和变量时，访问的是子类的成员函数和变量。但这样做是不安全的，往往子类对象所拥有的空间都比父类对象的大，因此用父类对象初始子类对象，其子类对象已溢出父类对象拥有的空间，因此溢出的这部分空间，操作系统可能会分配给其他对象，其他对象也可对此部分空间进行操作，因此是不安全的。  
