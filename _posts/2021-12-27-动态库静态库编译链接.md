## 动态库静态库编译链接 
### 静态库
#### 静态库生成方式：
+ 例如：**`ar -cr libtest.a test.o echo.o`**  
+ 静态库生成，其实质相当于将所有的.o文件打包成一个更大的.o文件，ar就是打包命令，其中c参数表示创建libtest.a文件，r参数表示将test.o和echo.o插入到libtest.a中  
#### 静态库的编译：
+ 链接位置：**`g++ main.cpp ./libtest.a -o main`**（不能将main.cpp放在./libtest.a语句之后）  
+ 指定位置：**`g++ main.cpp -L ./ -ltest -o main`**（不能将main.cpp放在-ltest语句之后）  

### 动态库
#### 动态库生成方式：
+ 例如：**`g++ -fPIC -shared test.c -o libtest.so`**  
+ 动态库生成，编译时需要-fPIC和-shared参数，其中fPIC参数表示生成与地址无关的编译文件，shared表示生成动态链接库。  
#### 动态库的两种使用方式：
+ 像普通函数一样使用动态库中的函数  
    + 使用时：需要包含动态库的头文件  
    + 编译时：需要指明链接动态库的名字(-lname)，动态库所在的位置(-L libso_position，如果库已在系统位置，可以不指明)  
    + 执行时：若找不到动态库(两种解决办法：**`1.编译时，加-Wl,-rpath,libso_position`** **`2.export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:libso_position`**)  
+ 使用dl库中的dlopen等函数，间接获取动态库中的函数
    + 使用时：一般不需要包含动态库的头文件，但需要包含dl库的头文件(**`<dlfcn.h>`**)，显示的使用dlopen函数打开指定位置的动态库，并使用dlsym等函数获取到动态库中的函数的handle，然后将其转换为对应的函数指针，最终使用函数指针的形式去调用函数。  
    + 编译时：需要链接dl动态库(-ldl)  
    + 执行时：注意动态库如果是cpp文件编译生成(建议由c文件生成)，则动态库中的函数符号，会发生变化，因此执行时，将查找不到对应的函数。  
